///////////////////////////////////////////////////////////////////////////////
//                
// Title:            (Tetris.java)
// Semester:         (CS8B) Fall 2018
//
// Author:           (Matthew Roth)
// Email:            (mrroth@ucsd.edu)
// CS Login:         (cs8bfds)
// Lecturer's Name:  (Prof. Paul Cao; TA's - Grace Chen, Alberto, Cheng, Emily,
//                     Godwin, Henry, Hensen, Hilda, Lavanya, Nishil, Sneha)
// 
// Class Desc:        The Tetris class is designed to be a program simulating
// 		      the game of tetris. The class has two constructors one with 
// 		      no args, another with paramter to take a txt file. The methods in
// 		      the class will perform operations that simulate the game of 
// 		      tetris. The core method of the Tetris class is the play() method 
// 		      which will be a play action method diaplying the current game state
// 		      and a toString representation of what the current game grid andgame
// 		      information is. The Tetris class uses a Piece object as a character
// 		      piece in the game play, and the Direction class is enum values to 
// 		      determine the direction the piece will move throughout the duration
// 		      of play. Once all peices have been consolidated in the game board 
// 		      grid with no room left to generate a new active piece, then the
// 		      game will be terminated. 
//                    
///////////////////////////////////////////////////////////////////////////////
import java.util.*;
import java.io.*;
import java.util.concurrent.*;

/**
 * the Tetris class will create a grid layout for the game board initialized 
 * with all space characters to represent an empty board. Then a piece will be
 * generated by creating a new Piece object and another piece will be generated
 * with nextPiece as an object. The game will start calling the play() method 
 * and the output will be displayed on the console as a toString() 
 * representation of what the current game looks like and the current stats. 
 * The important * instance variables are, linesCleared: to show how many lines
 * have been cleard so far. isGameover: a boolean to determined the status of 
 * the game activePiece: the current active game play piece object. activeCopy:
 * a copy of the current activePiece object to perform moves in the game. 
 * nextPiece:a piece object to be the next active peice in the game after the
 * previous piece has consolidated. usedHold: is the boolean to determine if 
 * the hold method has been called yet. grid: is the game board grid. 
 */
public class Tetris {

  public int linesCleared; // how many lines cleared so far

  public boolean isGameover;  // true if the game is over
  // false if the game is not over

  public Piece activePiece;   // holds a Piece object that can be moved
  // or rotated by the player

  private Piece activeCopy; // private instance variable to hold the activeCopy
  // Piece object for use in various methods

  public Piece nextPiece; // holds a Piece object that will become the new 
  // activePiece when the activePiece consolidates

  // The following 2 variables are used for the extra credit 
  public boolean usedHold = false;    // set to true if the player already 
  // used hold once since last piece 
  // consolidated

  public Piece storedPiece = null;   // holds the stored piece 

  public char[][] grid;   // contains all consolidated pieces, each tile  
  // represented by a char of the piece's shape
  // a position stores a space char if it is empty

  /**
   * the no args constructor to initialize the board game with
   *  a grid thats an array of empty space chars and create a new 
   *  piece object, new nextPiece object and set the isGameover to
   *  false starting a new game
   * */

  public Tetris(){
    //final int variables to hold the row size and column size of the game 
    //board grid 	  
    final int GRID_ROWS = 20;
    final int GRID_COL = 10;
    //set the lines cleared to zero 
    linesCleared = 0;
    //set the isGameover to false to start a new game 
    isGameover = false;
    //create a new game board grid of all empty space ' ' chars
    grid = new char[GRID_ROWS][GRID_COL];
    initializeGrid();
    //create a new actice piece object that will be used in the 
    //current play action 
    activePiece = new Piece('I');
    //create a next piece that will be ready for game play 
    nextPiece = new Piece('I');

  }
  /**
   * the initialize grid method will create a new array 
   * of space chars to simulate the game board
   * */

  private void initializeGrid(){
    //loop through the array and make every element a ' 'char
    for(int i = 0; i < grid.length;i++)
      for(int j= 0; j < grid[i].length;j++){
        grid[i][j] = ' ';  
      }
  }
  /**
   * method will set the active copy piece to the
   * paramter of a Piece object
   * @param activeCopy the copy object
   * 
   **/
  private void setActiveCopy(Piece activeCopy){
    //set the activeCopy to the incoming parameter
    this.activeCopy = activeCopy;
  }

  /**
   * the getActiveCopy method will return the
   * activeCopy reference to the copy Piece object
   * @return activeCopy the active copy piece object 
   **/
  private Piece getActiveCopy(){


    return activeCopy;
  }

  /**
   * the constructor with param filename will 
   * take input as a text file that will represent 
   * the previous game state, and re-start a game 
   * from that last point 
   * @param filename the txt file game state
   * */

  public Tetris (String filename) throws IOException {

    //call to the default constructor 	  
    this();
    //the number of rows to generate 
    final int GRID_ROWS = 20;
    //create a BufferedReader object to read each line in the text file 
    BufferedReader reader = new BufferedReader(new FileReader(filename));

    String currentLine = reader.readLine();

    //read the lines cleared int amount from the file and 
    //set the linesCleared instance variable to hold that value
    linesCleared = Integer.parseInt(currentLine);

    currentLine = reader.readLine();
    //set the shape instance variable of the active piece to be the
    //value the next char in the nextline
    activePiece.shape = currentLine.charAt(0);

    currentLine = reader.readLine();
    //set the nextPiece instance variable similar to the previous 
    //activePiece instance variable same idea
    nextPiece.shape = currentLine.charAt(0);

    //create an array of Strings to hold each line in the txt file
    String[] row_data = new String[GRID_ROWS];
    //loop through and read each line and set the row_data equal
    //to the line read from file 
    for (int i = 0; i<GRID_ROWS; i++){
      row_data[i] = reader.readLine();
    }
    //pull the char out at index indicated from the array of String
    for (int row=0; row<grid.length; row++){
      for (int col=0; col<grid[0].length; col++){
        grid[row][col] = row_data[row].charAt(col); 
      }
    }
    //close the reader 
    reader.close();
  }

  /**
   * the hasConflict method will take a Piece object as 
   * parameter, and determine if the piece in question
   * on the active game board is in violation by out of 
   * bounds on the grid or overlap with another active piece
   * on the grid
   * @param piece the piece to check for violation
   * @return the boolean value for conflict 
   * */
  public boolean hasConflict(Piece piece) {
    //the upper bound of the game grid for columns	  
    final int UPPER_BOUND = 9;
    //the lower bound for the game grid for rows
    final int LOWER_BOUND = 19;
    //if the piece array is storing a value of 1
    final int HAS_VALUE = 1;
    //loop through the array of the tile in the piece and check if the 
    //tile is containing a 1 or 0 and then check if that value is in conflict
    //with any location on the game grid
    for(int i = 0; i< piece.tiles.length;i++){
      for(int j = 0; j<piece.tiles.length;j++){
        if(piece.tiles[i][j] == HAS_VALUE){	
          if(j + piece.colOffset > UPPER_BOUND || j + piece.colOffset < 0)
            return true;
          else if(i + piece.rowOffset > LOWER_BOUND 
              || i + piece.rowOffset < -1) 
            return true;
          else if( grid[piece.rowOffset + i][piece.colOffset + j] != ' ')
            return true;
        }
      }      
    }
    return false;
  }

  /**
   * the consolidate method will save an active piece to the game
   * board grid once the piece has reached the bottom bounds of the 
   * grid or the piece has come into contact with another active piece on
   * the game board grid.
   * @return usedHold boolean for the hold() method 
   * */
  public void consolidate() {

    //loop through the tile array and set the corisponding location
    //on the grid to the same elements in the tile by using the 
    //colOffset and rowOffset as a reference
    for (int row=0; row<this.activePiece.tiles.length; row++)
      for (int col=0; col<this.activePiece.tiles[0].length; col++)
        if (activePiece.tiles[row][col] == 1){
          grid[row+activePiece.rowOffset]
            [col+activePiece.colOffset] = 
            activePiece.shape;
        }
    //set the hold piece back to false once the active piece has been 
    //consolidated 
    usedHold = false;
  }

  /**
   * the clearLines method will determine if an entire row on the game board
   * grid has all non ' ' space chars, and then if so it will clearthe row
   * and all the value in the row and set them back to all space chars
   * */
  public void clearLines() {
    //assume the row is going to be cleared until a space char is found
    boolean clearRow = true;
    //loop through the grid and check if each row has an empty char or not 
    for (int row=0; row<this.grid.length; row++){
      for (int col=0; col<this.grid[0].length; col++){
        //if the row contains even one space char, then set 
        //boolean clearRow to false and return       
        if(grid[row][col] == ' '){
          clearRow = false;          
        }
      } 
      //if clear row remains true, then the row did not contain any space
      //chars, and all the chars in the row were occupied with active piece 
      //chars.	
      if(clearRow == true){
        //create a temp grid to copy the old grid over before clearing lines
        char[][] temp_grid = new char[this.grid.length][this.grid[0].length];
        for (int row1=0; row1<this.grid.length; row1++)
          for (int col1=0; col1<this.grid[0].length; col1++)
            temp_grid[row1][col1] = this.grid[row1][col1];
        //clear the row and set each array element in the row back to ' ' space
        for (int row2 = 0; row2 < row + 1; row2++){
          for (int col2=0; col2<this.grid[0].length; col2++){
            if(row2 == 0){
              grid[0][col2] = ' ';
            }
            //shift the row above down one to compensate for the new clearedrow
            else{
              grid[row2][col2] = temp_grid[row2-1][col2];
            }
          }
        }
        //increment the lines cleared variable to hold how many lines have been
        //cleared in the current game 
        linesCleared++;                     
      }
      //set clear row back to true 
      clearRow = true;
    }   
  }

  /**
   * the move method will take a Direction object 
   * as a parameter and move the active piece in the 
   * direction determined by the Direction object enum
   * @param direction the direction to move the active piece
   * @return true/false depending if a conflict has arised
   * */
  public boolean move(Direction direction) {
    //create a copy of the active piece to move first	
    setActiveCopy(new Piece(activePiece));
    getActiveCopy().movePiece(direction);
    //if the active piece has a conflict and is moving down at the same time,
    //consolidate and end the game because the all the active pieces have 
    //reached the top of the grid 
    if(direction == Direction.DOWN && hasConflict(activePiece)){
      consolidate();
      clearLines();
      activePiece = new Piece(nextPiece);
      nextPiece = new Piece('I');
      isGameover = true; 
      return false;
    }
    //if the active copy piece has a conflict while also moving down it has 
    //either reached the bottom of the game board grid or it has come into 
    //contact with another active piece. so consolidate, clear any lines, and 
    //create a new active piece and new nextpiece	
    else if(direction == Direction.DOWN && hasConflict(getActiveCopy())){
      consolidate();
      clearLines();
      activePiece = new Piece(nextPiece);
      nextPiece = new Piece('I'); 
      return false;
    } 
    //make sure the active copy doesnt go out of bounds on the array for grid 
    else if(hasConflict(getActiveCopy())){
      setActiveCopy(new Piece(activePiece));    
      return false; 
    } 
    //no conflict has been determined for the activecopy, so move the active 
    //piece and continue play action
    else{
      activePiece.movePiece(direction);    
      return true;
    } 
  }
  /**
   * the drop method will continue to call the DOWNWARD move
   * until the piece has reached consolidation the bottom of the game 
   * boad grid or contact with a new active piece on the grid.
   * */
  public void drop() {
    //if no conflict has been determined then continue the loop with true 
    //boolean	  
    boolean moveable = true;
    //loop and keep calling the move DOWN enum until the moveable boolean has 
    //been set to false from the consolidation and hasconflict methods
    while(moveable){
      moveable = move(Direction.DOWN);

    }
  }
  /**
   * the roatate method will rotate the active copy first to determine if there
   * is a confict, and if no conflict exists it will rotate the active piece.
   * */
  public void rotate() {
    //create a copy of the active piece and then attempt to rotate that first 
    setActiveCopy(new Piece(activePiece));
    getActiveCopy().rotate();
    //make sure a piece at the top of the game board cannot be rotated
    if(getActiveCopy().rowOffset == -1 && getActiveCopy().shape != 'O')
      setActiveCopy(new Piece(activePiece));
    //if there is a conflict in the copy, then rest the piece to avoid an 
    //out of bound exception error 
    else if(hasConflict(getActiveCopy())){
      setActiveCopy(new Piece(activePiece));    
    }
    //no conflict, rotate the active piece 
    else
      activePiece.rotate();    
  }
  /**
   * the outputToFile method will generate a new txt file 
   * containing the most current play action in the game
   * */
  public void outputToFile() throws IOException {

    try{
      //create a FileWriter and BufferedWriter object to write relevan data 
      //into txt file
      FileWriter writer = new FileWriter("output.txt", true);
      BufferedWriter bufferedWriter = new BufferedWriter(writer);
      /*
       * write the next three lines to the txt file
       */
      bufferedWriter.write(Integer.toString(linesCleared));
      bufferedWriter.newLine();
      bufferedWriter.write(activePiece.shape);
      bufferedWriter.newLine();        
      bufferedWriter.write(nextPiece.shape);
      bufferedWriter.newLine();
      //write the current grid to the txt file 
      for(int row=0; row<grid.length; row++){
        for (int col=0; col<grid[0].length; col++){
          bufferedWriter.write(grid[row][col]); 
        }
        bufferedWriter.newLine();
      } 
      //close the writer 
      bufferedWriter.close();
    }catch (IOException e){
      e.printStackTrace();
    }
    //display a message that the output.txt has been created 
    System.out.println("Saved to output.txt");
  }

  /**
   * play method will create play action for the tetris game 
   * with various method calls and operations to simulate a
   * tetris game.
   * @return the game is over exit method 
   **/
  public void play() {
    Scanner input = new Scanner(System.in);
    String user;       
    //loop if the game is not over then continue playing
    //do one intitial game play then loop if the game is not over
    do{       
      System.out.print(toString());
      System.out.print("> ");
      user = input.nextLine();
      //switch case with determine what the user input is and execute the 
      //appropriate method call for game play 
      switch(user){
        //move piece left 
        case "a":
          move(Direction.LEFT);
          break;
          //move piece right 
        case "d":     
          move(Direction.RIGHT);
          break;
          //move piece down 
        case "s":
          move(Direction.DOWN);
          break;
          //rotate the piece   
        case "w":
          rotate();
          break;
          //drop the piece all the way down   
        case " ":
          drop();
          break;
          //output the current game to file, "save" game 
        case "o":
          try{
            outputToFile();
          }catch (IOException e){
            // This prints out an error message!
            System.err.println("SOS please someone help me");
          }
          break;
          //hold the current piece for later use   
        case "z":
          hold();
          break;
          //quit the game 
        case "q":
          isGameover = true;
          break;
          //if and invalid entry has been input by the user then 
          //print the line and continue the loop 
        default:
          System.out.println("Incorrect entry. Please try again.");
          break;
      }
    }while(isGameover == false); 
    //print one last instance of the active game board grid with the active 
    //pieces and most recent game state
    System.out.print(toString());
    //print the total amount of lines cleared for the game 
    System.out.println("\nLines cleared: " + this.linesCleared + '\n');

    return;
  }

  /**
   * returns the string representation of the Tetris game state in the 
   * following format:
   *  Lines cleared: [number]
   *  Next piece: [char]  (Stored piece: [char])
   *  char[20][10]
   * @return string representation of the Tetris game
   */

  @Override
  public String toString() {
    StringBuilder str = new StringBuilder();

    str.append("\nLines cleared: " + this.linesCleared + '\n');

    str.append("Next piece: " + this.nextPiece.shape);
    if (this.storedPiece == null) str.append("\n");
    else str.append("  Stored piece: " + this.storedPiece.shape + '\n');

    str.append("| - - - - - - - - - - |\n");

    /*deep copy the grid*/
    char[][] temp_grid = new char[this.grid.length][this.grid[0].length];
    for (int row=0; row<this.grid.length; row++)
      for (int col=0; col<this.grid[0].length; col++)
        temp_grid[row][col] = this.grid[row][col];

    /*put the active piece in the temp grid*/
    for (int row=0; row<this.activePiece.tiles.length; row++)
      for (int col=0; col<this.activePiece.tiles[0].length; col++)
        if (activePiece.tiles[row][col] == 1)
          temp_grid[row+activePiece.rowOffset]
            [col+activePiece.colOffset] = 
            activePiece.shape;

    /*print the temp grid*/
    for (int row=0; row<temp_grid.length; row++){
      str.append('|');
      for (int col=0; col<temp_grid[0].length; col++){
        str.append(' ');
        str.append(temp_grid[row][col]);
      }
      str.append(" |\n");
    }

    str.append("| - - - - - - - - - - |\n");
    return str.toString();        
  }

  /**
   * the hold method is an extra credit option that when 
   * implemented the active piece will be put into a hold
   * position, and a new active piece will be generated. The piece 
   * in hold can be later called. this method can only be called once 
   * between consolidated peices
   * */
  public void hold() {
    //if the hold method has not been called once already bewteen 
    //consolidation 
    if(!usedHold){
      activePiece = new Piece(activePiece.shape);
      if(storedPiece == null){
        storedPiece = new Piece(activePiece);
        activePiece = new Piece(nextPiece);
        nextPiece = new Piece();
      }
      //hold the active piece in storage an create a new piece object 
      else{
        Piece temp = new Piece(storedPiece);
        storedPiece = new Piece(activePiece);
        activePiece = new Piece(temp);
      }

      usedHold = true;
    }
  }

  /**
   * first method called during program execution
   * @param args: an array of String when running the program from the 
   * command line, either empty, or contains a valid filename to load
   * the Tetris game from
   */
  public static void main(String[] args) {

    if (args.length != 0 && args.length != 1) {
      System.err.println("Usage: java Tetris / java Tetris <filename>");
      return;
    }
    try {
      Tetris tetris;
      if (args.length == 0) tetris = new Tetris();
      else tetris = new Tetris(args[0]);
      tetris.play();
    } catch (Exception e) {
      e.printStackTrace();
    }

  }
}
